/** This file is in the public domain.
 *
 * @homepage http://github.com/pabigot/bsp430
 *
 */

#include <bsp430/platform.h>
#include <bsp430/utility/led.h>
#include <bsp430/periph/port.h>
#include <bsp430/utility/console.h>
#include <bsp430/utility/uptime.h>
#include <bsp430/periph/timer.h>
#include <bsp430/periph/sys.h>
#include <bsp430/sensors/utility.h>
#include <stddef.h>
#include <string.h>

/* Sanity check that the features we requested are present */
#if ! (BSP430_CONSOLE - 0)
#error Console is not configured correctly
#endif /* BSP430_CONSOLE */
/* Sanity check that the features we requested are present */
#if ! (BSP430_UPTIME - 0)
#error Uptime is not configured correctly
#endif /* BSP430_UPTIME */

/* Specify the bits and port corresponding to the I2C SDA and SCL
 * signals */
#if (BSP430_PLATFORM_EXP430F5529LP - 0)
#define SDA_BIT BIT1
#define SCL_BIT BIT2
#define PxOUT P4OUT
#else /* PLATFORM */
#error No configuration for platform
#endif /* PLATFORM */

static void
delay_half_cycle (void)
{
  BSP430_CORE_DELAY_CYCLES(50);
}

static void
emit_bit (bool high)
{
  PxOUT &= ~SCL_BIT;
  if (high) {
    PxOUT |= SDA_BIT;
  } else {
    PxOUT &= ~SDA_BIT;
  }
  delay_half_cycle();
  PxOUT |= SCL_BIT;
  delay_half_cycle();
}

/* AM2315 has a wake-up sequence that apparently can't be generated by
 * the MSP430 I2C peripheral: the stop condition can't be transmitted
 * for at least 800 us.  So bit-bang it. */
void
emit_wakeup (void)
{
  /* Address plus R/Wn plus ACK */
  const unsigned int value = (APP_AM2315_I2C_ADDRESS << 2) | 1;
  unsigned int mask = 0x100;

  /* Initial condition is SDA and SCL high */
  PxOUT |= (SDA_BIT | SCL_BIT);
  delay_half_cycle();
  /* Start condition: pull SDA low while SCL high */
  PxOUT &= ~SDA_BIT;
  delay_half_cycle();
  /* Transmit write to address and ack */
  while (mask) {
    emit_bit(mask & value);
    mask >>= 1;
  }
  /* Pull SDA and SCL low for 800us to 3 ms */
  PxOUT &= ~(SDA_BIT | SCL_BIT);
  BSP430_UPTIME_DELAY_MS_NI(1, LPM3_bits, 0);
  /* Stop condition: pull SDA high while SCL HIGH */
  PxOUT |= SCL_BIT;
  PxOUT |= SDA_BIT;
  delay_half_cycle();
}

void main ()
{
  hBSP430halSERIAL i2c = hBSP430serialLookup(APP_AM2315_I2C_PERIPH_HANDLE);
  int rc;

  vBSP430platformInitialize_ni();

  (void)iBSP430consoleInitialize();
  cprintf("\nApplication starting\n");

  cprintf("AM2315 I2C on %s at %p, bus rate %lu Hz, address 0x%02x\n",
          xBSP430serialName(APP_AM2315_I2C_PERIPH_HANDLE) ?: "UNKNOWN",
          i2c, (unsigned long)BSP430_SERIAL_I2C_BUS_SPEED_HZ,
          APP_AM2315_I2C_ADDRESS);
#if BSP430_PLATFORM_PERIPHERAL_HELP
  cprintf("AM2315 I2C Pins: %s\n", xBSP430platformPeripheralHelp(APP_AM2315_I2C_PERIPH_HANDLE, BSP430_PERIPHCFG_SERIAL_I2C));
#endif /* BSP430_PLATFORM_PERIPHERAL_HELP */

  i2c = hBSP430serialOpenI2C(i2c,
                             BSP430_SERIAL_ADJUST_CTL0_INITIALIZER(UCMST),
                             0, 0);
  if (! i2c) {
    cprintf("I2C open failed.\n");
    return;
  }

  /* We leave I2C in hold when not active, because we need to use its
   * SDA and SCL lines as GPIOs to manage the wake condition. */
  iBSP430serialSetHold_rh(i2c, 1);
  (void)iBSP430i2cSetAddresses_rh(i2c, -1, APP_AM2315_I2C_ADDRESS);

  while (1) {
    const uint8_t read_ht[] = { 0x03, 0x00, 0x04 };
    char as_text[BSP430_UPTIME_AS_TEXT_LENGTH];
    struct ht_crc_type {
      uint8_t fcode;
      uint8_t len;
      uint8_t high_rh_ppt;
      uint8_t low_rh_ppt;
      uint8_t high_dCel;
      uint8_t low_dCel;
      uint8_t low_crc;
      uint8_t high_crc;
    } ht_crc;
    int temp_dCel;
    int rh_ppt;

    /* Bit-bang the wake-up sequence */
    emit_wakeup();

    /* Take I2C out of hold to read the settings */
    iBSP430serialSetHold_rh(i2c, 0);
    rc = iBSP430i2cTxData_rh(i2c, read_ht, sizeof(read_ht));
    if (0 < rc) {
      rc = iBSP430i2cRxData_rh(i2c, (uint8_t*)&ht_crc, sizeof(ht_crc));
    }
    iBSP430serialSetHold_rh(i2c, 1);
    if (0 > rc) {
      break;
    }

    {
      uint16_t rx_crc = (ht_crc.high_crc << 8) | ht_crc.low_crc;
      uint16_t crc = ~0;
      const uint8_t * dp = (uint8_t*)&ht_crc;
      unsigned int rem = offsetof(struct ht_crc_type, low_crc);
      while (rem--) {
        int bi;
        crc ^= *dp++;
        for (bi = 0; bi < 8; ++bi) {
          if (crc & 1) {
            crc >>= 1;
            crc ^= 0xA001;
          } else {
            crc >>= 1;
          }
        }
      }
      if (rx_crc != crc) {
        cprintf("ERR: Bad CRC %04x from : ", rx_crc);
        vBSP430consoleDisplayOctets((const uint8_t*)&ht_crc, sizeof(ht_crc));
        cprintf(": expect %04x\n", crc);
      }
    }

    rh_ppt = (ht_crc.high_rh_ppt << 8) | ht_crc.low_rh_ppt;
    temp_dCel = ((0x7F & ht_crc.high_dCel) << 8) | ht_crc.low_dCel;
    if (0x80 & ht_crc.high_dCel) {
      temp_dCel = -temp_dCel;
    }

    cprintf("%s : Temp %d dCel = %d d[Fahr], humidity %u ppt\n",
            xBSP430uptimeAsText(ulBSP430uptime(), as_text),
            temp_dCel, BSP430_SENSORS_CONVERT_dC_TO_dFahr(temp_dCel),
            rh_ppt);

    BSP430_UPTIME_DELAY_MS_NI(5000, LPM3_bits, 0);
  }
  cprintf("Aborted due to result code %d\n", rc);
}
