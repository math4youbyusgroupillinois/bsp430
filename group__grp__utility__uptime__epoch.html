<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>BSP430: Epoch Support for the Uptime Timer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BSP430
   &#160;<span id="projectnumber">20141115</span>
   </div>
   <div id="projectbrief">Board Support Package for MSP430 microcontrollers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Epoch Support for the Uptime Timer</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="uptime_8h.html" title="Support for maintaining a system uptime counter. ">bsp430/utility/uptime.h</a> data structures and functions supporting conversion between civil time and the uptime facility.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsBSP430uptimeNTPShortFormat.html">sBSP430uptimeNTPShortFormat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsBSP430uptimeNTPTimestamp.html">sBSP430uptimeNTPTimestamp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsBSP430uptimeNTPPacketHeader.html">sBSP430uptimeNTPPacketHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac695cb10d584a5076ab466325fe87cbd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#gac695cb10d584a5076ab466325fe87cbd">BSP430_UPTIME_POSIX_EPOCH_NTPIS</a>&#160;&#160;&#160;2208988800UL</td></tr>
<tr class="separator:gac695cb10d584a5076ab466325fe87cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55e82a7b83eb5d2527b633b05da7c611"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga55e82a7b83eb5d2527b633b05da7c611">BSP430_UPTIME_BYPASS_EPOCH_NTP</a>&#160;&#160;&#160;((uint64_t)(<a class="el" href="group__grp__utility__uptime__epoch.html#gac695cb10d584a5076ab466325fe87cbd">BSP430_UPTIME_POSIX_EPOCH_NTPIS</a> + 1388534400UL) &lt;&lt; 32)</td></tr>
<tr class="separator:ga55e82a7b83eb5d2527b633b05da7c611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eae053125133f9e6bd7b0975faf2346"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga0eae053125133f9e6bd7b0975faf2346">BSP430_UPTIME_EPOCH_UPDATE_INTERVAL_UTT</a>&#160;&#160;&#160;0x40000000L</td></tr>
<tr class="separator:ga0eae053125133f9e6bd7b0975faf2346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga120a86e292720a8304920856cf4d969f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga120a86e292720a8304920856cf4d969f">BSP430_UPTIME_EPOCH_VALID_OFFSET_UTT</a>&#160;&#160;&#160;0x60000000L</td></tr>
<tr class="separator:ga120a86e292720a8304920856cf4d969f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5f55b02ec7e0b0fb400718b7add22f0a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsBSP430uptimeNTPShortFormat.html">sBSP430uptimeNTPShortFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga5f55b02ec7e0b0fb400718b7add22f0a">sBSP430uptimeNTPShortFormat</a></td></tr>
<tr class="separator:ga5f55b02ec7e0b0fb400718b7add22f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057de2cee4aab178d2448c1a0a814bb1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsBSP430uptimeNTPTimestamp.html">sBSP430uptimeNTPTimestamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga057de2cee4aab178d2448c1a0a814bb1">sBSP430uptimeNTPTimestamp</a></td></tr>
<tr class="separator:ga057de2cee4aab178d2448c1a0a814bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac941bf3f0730d029f956cfe8f7028304"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsBSP430uptimeNTPPacketHeader.html">sBSP430uptimeNTPPacketHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#gac941bf3f0730d029f956cfe8f7028304">sBSP430uptimeNTPPacketHeader</a></td></tr>
<tr class="separator:gac941bf3f0730d029f956cfe8f7028304"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaca58b08a55f4abbb00d68445967c1082"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#gaca58b08a55f4abbb00d68445967c1082">iBSP430uptimeCheckEpochValidity</a> ()</td></tr>
<tr class="separator:gaca58b08a55f4abbb00d68445967c1082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbf9d7cbabe6c7060d94eccd41adff07"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#gacbf9d7cbabe6c7060d94eccd41adff07">ulBSP430uptimeLastEpochUpdate</a> ()</td></tr>
<tr class="separator:gacbf9d7cbabe6c7060d94eccd41adff07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6f91fb75c529345a0ac630c8360407"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga1b6f91fb75c529345a0ac630c8360407">lBSP430uptimeEpochAge</a> ()</td></tr>
<tr class="separator:ga1b6f91fb75c529345a0ac630c8360407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e8bb729f03dfd364a54b85bb6c75729"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga7e8bb729f03dfd364a54b85bb6c75729">iBSP430uptimeEpochEra</a> (unsigned long time_utt)</td></tr>
<tr class="separator:ga7e8bb729f03dfd364a54b85bb6c75729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1466203a5508214f4e6c5b55117c9fcf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga1466203a5508214f4e6c5b55117c9fcf">iBSP430uptimeInitializeNTPRequest</a> (<a class="el" href="structsBSP430uptimeNTPPacketHeader.html">sBSP430uptimeNTPPacketHeader</a> *ntpp)</td></tr>
<tr class="separator:ga1466203a5508214f4e6c5b55117c9fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac658e909e152bf3f821b9c96680e1a61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#gac658e909e152bf3f821b9c96680e1a61">iBSP430uptimeSetNTPXmtField</a> (<a class="el" href="structsBSP430uptimeNTPPacketHeader.html">sBSP430uptimeNTPPacketHeader</a> *ntpp, unsigned long *putt)</td></tr>
<tr class="separator:gac658e909e152bf3f821b9c96680e1a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420f53365274ecc364c65fc615e57940"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga420f53365274ecc364c65fc615e57940">iBSP430uptimeSetEpochFromNTP</a> (uint64_t epoch_ntp)</td></tr>
<tr class="separator:ga420f53365274ecc364c65fc615e57940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac179402eadc08fb25cddf49bc1d4bb74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#gac179402eadc08fb25cddf49bc1d4bb74">iBSP430uptimeAdjustEpochFromNTP</a> (int64_t adjustment_ntp)</td></tr>
<tr class="separator:gac179402eadc08fb25cddf49bc1d4bb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64b867564c88a94f49074fe2dff66bb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga64b867564c88a94f49074fe2dff66bb5">iBSP430uptimeSetEpochFromTimeval</a> (const struct timeval *tv, unsigned long when_utt)</td></tr>
<tr class="separator:ga64b867564c88a94f49074fe2dff66bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3495d789a656fb2f5ab6fa059bd4098a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga3495d789a656fb2f5ab6fa059bd4098a">iBSP430uptimeAsNTP</a> (unsigned long utt, uint64_t *ntpp, int bypass_validation)</td></tr>
<tr class="separator:ga3495d789a656fb2f5ab6fa059bd4098a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc50826a19222664ec857c0b75ab6e31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#gacc50826a19222664ec857c0b75ab6e31">iBSP430uptimeAsTimeval</a> (unsigned long utt, struct timeval *tv)</td></tr>
<tr class="separator:gacc50826a19222664ec857c0b75ab6e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca2a9bd04be064e542473f4157fde06"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga1ca2a9bd04be064e542473f4157fde06">xBSP430uptimeAsPOSIXTime</a> (unsigned long utt)</td></tr>
<tr class="separator:ga1ca2a9bd04be064e542473f4157fde06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632fda6455467a5e05b9dd9929191321"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__grp__utility__uptime__epoch.html#ga632fda6455467a5e05b9dd9929191321">iBSP430uptimeProcessNTPResponse</a> (const <a class="el" href="structsBSP430uptimeNTPPacketHeader.html">sBSP430uptimeNTPPacketHeader</a> *req, const <a class="el" href="structsBSP430uptimeNTPPacketHeader.html">sBSP430uptimeNTPPacketHeader</a> *resp, uint64_t rec_ntp, int64_t *adjustment_ntp, long *adjustment_ms, unsigned long *rtt_us)</td></tr>
<tr class="separator:ga632fda6455467a5e05b9dd9929191321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="uptime_8h.html" title="Support for maintaining a system uptime counter. ">bsp430/utility/uptime.h</a> data structures and functions supporting conversion between civil time and the uptime facility. </p>
<dl class="section note"><dt>Note</dt><dd>This functionality depends on <a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a>.</dd></dl>
<p>The uptime clock in BSP430 supports a 32-bit monotonically non-decreasing fixed-frequency counter used for low-resolution timing. Normally the clock is based on a 32 kiHz crystal; this can be divided, or the clock may be based on VLOCLK at roughly 10 kHz. Thus the minimum duration representable without wrapping is about 36 hours. The <em>era</em> of the uptime clock is the number of times it has wrapped since the system started. (For your amusement, the era can be found in the upper 16 bits of the <a class="el" href="structsBSP430halTIMER.html#a94c752d47f766f39ee94040222184741">overflow counter </a> of the <a class="el" href="uptime_8h.html#a9dea5efac11cf472a643af6c03929fdf">associated timer</a>, but it is not used in this feature.)</p>
<p>In some applications it's necessary to correlate the internal time with a time standard such as UTC. While many MSP430s have a real-time clock that can assist in representing long durations, the key issue is registering the internal clock with a time standard. BSP430 supports this with the concept of an (uptime) <em>epoch</em>, being a representation of a time that corresponds to the start of an era, accurate to the resolution of the uptime clock.</p>
<p>As the era can change asynchronously to epoch updates, the following expectation affect use of the uptime epoch facility:</p>
<ul>
<li>There is no valid epoch until the application provides one, through <a class="el" href="group__grp__utility__uptime__epoch.html#ga420f53365274ecc364c65fc615e57940">iBSP430uptimeSetEpochFromNTP()</a> or <a class="el" href="group__grp__utility__uptime__epoch.html#ga64b867564c88a94f49074fe2dff66bb5">iBSP430uptimeSetEpochFromTimeval()</a>.</li>
</ul>
<ul>
<li>If there is no valid epoch, the functions that convert to time standards (e.g., <a class="el" href="group__grp__utility__uptime__epoch.html#gacc50826a19222664ec857c0b75ab6e31">iBSP430uptimeAsTimeval()</a>, <a class="el" href="group__grp__utility__uptime__epoch.html#ga1ca2a9bd04be064e542473f4157fde06">xBSP430uptimeAsPOSIXTime()</a>) return an error.</li>
</ul>
<ul>
<li>The epoch must be explicitly updated at least once every <a class="el" href="group__grp__utility__uptime__epoch.html#ga0eae053125133f9e6bd7b0975faf2346">BSP430_UPTIME_EPOCH_UPDATE_INTERVAL_UTT</a> ticks (1/4 era, or about nine hours at 32 kiHz).</li>
</ul>
<ul>
<li>Times that are to be converted must be within <a class="el" href="group__grp__utility__uptime__epoch.html#ga120a86e292720a8304920856cf4d969f">BSP430_UPTIME_EPOCH_VALID_OFFSET_UTT</a> ticks (3/8 era, or about 13 hours at 32 kiHz) before or after the time the epoch was last updated. <dl class="section warning"><dt>Warning</dt><dd>Conversion of a time outside this range will invalidate the epoch.</dd></dl>
</li>
<li>The uptime epoch is invalidated when the uptime clock is <a class="el" href="uptime_8h.html#a62fc249f2c4699ab77b408e3488ca4b5">suspended</a> .</li>
</ul>
<dl class="section user"><dt>Homepage</dt><dd><a href="http://github.com/pabigot/bsp430">http://github.com/pabigot/bsp430</a> </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2012-2014, Peter A. Bigot. Licensed under <a href="http://www.opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a> </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga55e82a7b83eb5d2527b633b05da7c611"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSP430_UPTIME_BYPASS_EPOCH_NTP&#160;&#160;&#160;((uint64_t)(<a class="el" href="group__grp__utility__uptime__epoch.html#gac695cb10d584a5076ab466325fe87cbd">BSP430_UPTIME_POSIX_EPOCH_NTPIS</a> + 1388534400UL) &lt;&lt; 32)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An NTP timestamp for a time known to be within 34 years of any current server. The calculations of offset and round trip in section 8 "On-wire Protocol" of <a href="http://tools.ietf.org/html/rfc5905">RFC5905</a> are valid only when the client and server are no more than 34 years apart. This is the epoch used when <code>bypass_validity</code> is used in <a class="el" href="group__grp__utility__uptime__epoch.html#ga3495d789a656fb2f5ab6fa059bd4098a">iBSP430uptimeAsNTP()</a>, as is the case when doing NTP client/server communications prior to obtaining a valid epoch.</p>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0eae053125133f9e6bd7b0975faf2346"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSP430_UPTIME_EPOCH_UPDATE_INTERVAL_UTT&#160;&#160;&#160;0x40000000L</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of uptime ticks between updates to the epoch, if epoch consistency is to be maintained.</p>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga120a86e292720a8304920856cf4d969f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSP430_UPTIME_EPOCH_VALID_OFFSET_UTT&#160;&#160;&#160;0x60000000L</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of uptime ticks between an uptime value and the last time the epoch was updated that will not cause epoch invalidation if used to convert the uptime value.</p>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac695cb10d584a5076ab466325fe87cbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSP430_UPTIME_POSIX_EPOCH_NTPIS&#160;&#160;&#160;2208988800UL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The time of the POSIX epoch (1970-01-01T00:00:00Z) as represented in integral seconds since the NTP epoch (1900-01-01T00:00:00Z).</p>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gac941bf3f0730d029f956cfe8f7028304"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsBSP430uptimeNTPPacketHeader.html">sBSP430uptimeNTPPacketHeader</a>  <a class="el" href="structsBSP430uptimeNTPPacketHeader.html">sBSP430uptimeNTPPacketHeader</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a href="http://tools.ietf.org/html/rfc5905#section-7.3">RFC5905 (NTP v4)</a> packet header. Extension fields are not supported in this implementation.</p>
<dl class="section note"><dt>Note</dt><dd>In almost no situations does a user need to inspect or mutate the fields of this structure. Use <a class="el" href="group__grp__utility__uptime__epoch.html#ga1466203a5508214f4e6c5b55117c9fcf">iBSP430uptimeInitializeNTPRequest()</a> to initialize the structure, and <a class="el" href="group__grp__utility__uptime__epoch.html#gac658e909e152bf3f821b9c96680e1a61">iBSP430uptimeSetNTPXmtField()</a> to set the transmission time.</dd></dl>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f55b02ec7e0b0fb400718b7add22f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsBSP430uptimeNTPShortFormat.html">sBSP430uptimeNTPShortFormat</a>  <a class="el" href="structsBSP430uptimeNTPShortFormat.html">sBSP430uptimeNTPShortFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a href="http://tools.ietf.org/html/rfc5905#section-6">RFC5905 (NTP v4)</a> structure to represent a short-format time (more accurately, a duration, as there is no epoch).</p>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga057de2cee4aab178d2448c1a0a814bb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsBSP430uptimeNTPTimestamp.html">sBSP430uptimeNTPTimestamp</a>  <a class="el" href="structsBSP430uptimeNTPTimestamp.html">sBSP430uptimeNTPTimestamp</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a href="http://tools.ietf.org/html/rfc5905#section-6">RFC5905 (NTP v4)</a> structure to represent a timestamp, measured in 2^32 Hz ticks since the NTP epoch 1900-01-01T00:00:00Z.</p>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac179402eadc08fb25cddf49bc1d4bb74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iBSP430uptimeAdjustEpochFromNTP </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>adjustment_ntp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adjust the uptime epoch using a relative NTP timestamp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjustment_ntp</td><td>the number of ticks of a 2^32 Hz clock that must be added to the epoch to cause the local time to coincide with a reference clock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3495d789a656fb2f5ab6fa059bd4098a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iBSP430uptimeAsNTP </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>utt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>ntpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bypass_validation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a time to an NTP timestamp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">utt</td><td>count of ticks since the last time the uptime clock rolled over.</td></tr>
    <tr><td class="paramname">ntpp</td><td>where to store the time represented by <code>utt</code> as the number of 2^32 Hz ticks since the NTP epoch (1900-01-01T00:00:00Z).</td></tr>
    <tr><td class="paramname">bypass_validation</td><td>a flag that bypasses the normal check to see that the epoch is valid. When set to a true value and the epoch is invalid, a pseudo-epoch corresponding to 2014-01-01T00:00:00Z is used so that a client NTP request packet can be formed with a valid transmission timestamp. You will need to set this flag when obtaining the <code>rec_ntp</code> parameter to <a class="el" href="group__grp__utility__uptime__epoch.html#ga632fda6455467a5e05b9dd9929191321">iBSP430uptimeProcessNTPResponse()</a> when the epoch is invalid. If the epoch is valid, this flag is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if conversion is successful, otherwise a negative error code.</dd></dl>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacc50826a19222664ec857c0b75ab6e31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iBSP430uptimeAsTimeval </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>utt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the current time to microsecond resolution by adding the uptime clock time in <code>utt</code> to a configured offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">utt</td><td>the uptime clock value</td></tr>
    <tr><td class="paramname">tv</td><td>where to store the converted time. The referenced object is left unchanged if the conversion fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative error code if the epoch is not valid or something else went wrong.</dd></dl>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaca58b08a55f4abbb00d68445967c1082"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iBSP430uptimeCheckEpochValidity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return 0 if there is an epoch that is presumed to be valid, or a negative error if no epoch is available.</p>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e8bb729f03dfd364a54b85bb6c75729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iBSP430uptimeEpochEra </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>time_utt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine which era <code>time_utt</code> belongs to for the purposes of conversion using the current epoch.</p>
<p>Reasons for invalidity include: </p><ul>
<li>There is no valid epoch at all (<a class="el" href="group__grp__utility__uptime__epoch.html#gaca58b08a55f4abbb00d68445967c1082">iBSP430uptimeCheckEpochValidity()</a>)</li>
</ul>
<ul>
<li><code>time_utt</code> is more than <a class="el" href="group__grp__utility__uptime__epoch.html#ga120a86e292720a8304920856cf4d969f">BSP430_UPTIME_EPOCH_VALID_OFFSET_UTT</a> ticks earlier or later than the time the epoch was last updated</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_utt</td><td>the time at which conversion is being proposed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a negative code if <code>time_utt</code> cannot be converted. Non-negative results indicate the era, relative to the era the epoch was set for, in which <code>time_utt</code> lies (0 for the preceding, 1 for the same, 2 for the next).</dd></dl>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1466203a5508214f4e6c5b55117c9fcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iBSP430uptimeInitializeNTPRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBSP430uptimeNTPPacketHeader.html">sBSP430uptimeNTPPacketHeader</a> *&#160;</td>
          <td class="paramname"><em>ntpp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize an NTP packet to serve as a request for the current time.</p>
<p>This initializes the leap-information, version, and mode flags, and sets the precision based on the local uptime clock. No timestamps are stored; see iBSP430uptimeNTPUpdateXmtField().</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative error code on failure.</dd></dl>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga632fda6455467a5e05b9dd9929191321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iBSP430uptimeProcessNTPResponse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBSP430uptimeNTPPacketHeader.html">sBSP430uptimeNTPPacketHeader</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsBSP430uptimeNTPPacketHeader.html">sBSP430uptimeNTPPacketHeader</a> *&#160;</td>
          <td class="paramname"><em>resp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>rec_ntp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>adjustment_ntp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>adjustment_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>rtt_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process an NTP response.</p>
<p>This calculates the offset between the local uptime clock and the time provided by an external server.</p>
<p>The request and response packets are validated for server stratum, mismatched, and duplicate/bogus/replayed packets. Failure of these checks results in an error return.</p>
<dl class="section warning"><dt>Warning</dt><dd>On successful processing, the internally-stored uptime epoch is adjusted to account for the difference between local and server times.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>pointer to the locally-generated request packet. This may be null if you don't care to (or cannot) validate that the response origin time matches the request transmit time.</td></tr>
    <tr><td class="paramname">resp</td><td>pointer to the response packet. This must be provided and must be valid.</td></tr>
    <tr><td class="paramname">rec_ntp</td><td>the time when the response packet was received locally, in NTP 2^32 Hz ticks since the NTP epoch. Use <a class="el" href="group__grp__utility__uptime__epoch.html#ga3495d789a656fb2f5ab6fa059bd4098a">iBSP430uptimeAsNTP()</a> to convert from a local uptime measurement.</td></tr>
    <tr><td class="paramname">adjustment_ntp</td><td>optional (but recommended) location into which the delta between the local time and the server will be stored (a positive value indicates that the local time is behind the server). When a valid epoch is already available, this value is suitable for passing unmodified to <a class="el" href="group__grp__utility__uptime__epoch.html#gac179402eadc08fb25cddf49bc1d4bb74">iBSP430uptimeAdjustEpochFromNTP()</a>. When a valid epoch is not available, this value should be added to <a class="el" href="group__grp__utility__uptime__epoch.html#ga55e82a7b83eb5d2527b633b05da7c611">BSP430_UPTIME_BYPASS_EPOCH_NTP</a> and the result passed to <a class="el" href="group__grp__utility__uptime__epoch.html#ga420f53365274ecc364c65fc615e57940">iBSP430uptimeSetEpochFromNTP()</a>.</td></tr>
    <tr><td class="paramname">adjustment_ms</td><td>optional location in which the adjustment, converted to milliseconds, will be stored. This is primarily intended for diagnostics, as a value in milliseconds is more useful than the 2^32 Hz tick count provided by <code>adjustment_ntp</code>. If the offset cannot be represented in the space available, the signed maximum value will be stored. If the offset is not of interest, pass a null pointer. The value is not stored if this function returns an error.</td></tr>
    <tr><td class="paramname">rtt_us</td><td>optional location in which to store the estimated round-trip time for request and response. If the round-trip time cannot be represented (which should never happen), the maximum representable value will be stored. If the round-trip time is not of interest, pass a null pointer. The value is not stored if this function returns an error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative error code on failure</dd></dl>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga420f53365274ecc364c65fc615e57940"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iBSP430uptimeSetEpochFromNTP </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>epoch_ntp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the uptime epoch using an absolute NTP timestamp.</p>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga64b867564c88a94f49074fe2dff66bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iBSP430uptimeSetEpochFromTimeval </td>
          <td>(</td>
          <td class="paramtype">const struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>when_utt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the uptime epoch using an absolute Unix time value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tv</td><td>a civil time value</td></tr>
    <tr><td class="paramname">when_utt</td><td>the time within the current era at which <code>tv</code> is current.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise a negative error code.</dd></dl>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac658e909e152bf3f821b9c96680e1a61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iBSP430uptimeSetNTPXmtField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBSP430uptimeNTPPacketHeader.html">sBSP430uptimeNTPPacketHeader</a> *&#160;</td>
          <td class="paramname"><em>ntpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>putt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the <a class="el" href="structsBSP430uptimeNTPPacketHeader.html#ac85e5222e743583018f5c0d638d978b2">sBSP430uptimeNTPPacketHeader::xmt</a> field.</p>
<p>This should be called just prior to (or while) transmitting an NTP request to ensure it holds the most accurate estimate of transmission time available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ntpp</td><td>pointer to the NTP packet to be updated</td></tr>
    <tr><td class="paramname">putt</td><td>pointer to the uptime clock value to be stored as transmission time. If this is a null pointer, the current time is stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative error code on failure.</dd></dl>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b6f91fb75c529345a0ac630c8360407"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long lBSP430uptimeEpochAge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of uptime ticks since the epoch was last updated.</p>
<p>A negative value is returned if the epoch is not valid, or has not been updated within the last half era.</p>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacbf9d7cbabe6c7060d94eccd41adff07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long ulBSP430uptimeLastEpochUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the uptime clock value at which the epoch was last updated.</p>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ca2a9bd04be064e542473f4157fde06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t xBSP430uptimeAsPOSIXTime </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>utt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the current time expressed as seconds since the POSIX epoch.</p>
<p>This invokes <a class="el" href="group__grp__utility__uptime__epoch.html#gacc50826a19222664ec857c0b75ab6e31">iBSP430uptimeAsTimeval()</a> and returns the <code>tv_sec</code> field of the resulting structure.</p>
<dl class="section note"><dt>Note</dt><dd>If the epoch is not valid for the time, the returned value will be <code></code>(time_t)-1.</dd></dl>
<dl class="section user"><dt>Dependency:</dt><dd><a class="el" href="uptime_8h.html#a61dba25c9c2606cf5acb2595c5162d42">configBSP430_UPTIME_EPOCH</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Nov 15 2014 11:27:14 for BSP430 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
